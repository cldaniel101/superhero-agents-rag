# Aula de RAG

## Objetivo da aula (o que os alunos vão sair sabendo)

1. Explicar o que é RAG de forma intuitiva e quando usar. ([Google Cloud](https://cloud.google.com/use-cases/retrieval-augmented-generation?utm_source=chatgpt.com))
2. Entender a “peça de Lego” do ADK: **Agent + Tools + Runner + Session**. ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
3. Criar um **RAG Agent no Google ADK** usando o tool built-in `VertexAiRagRetrieval`. ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
4. Rodar e testar o agente localmente, com exemplos práticos.

Tempo sugerido: **1h30 a 2h**.

---

## Pré-requisitos (bem leves)

- Python básico (variáveis, `pip`, rodar arquivo).
- Conta no Google Cloud **ou** alguém já deixar um projeto configurado pra turma.
- Uma pasta com PDFs/textos que serão a “base de conhecimento”.

Instalação do ADK:

```bash
pip install google-adk

```

(é o pacote oficial recomendado). ([GitHub](https://github.com/google/adk-python))

Se for usar ferramentas Vertex AI (como RAG Engine), instale os extras: `google-adk[vertexai]`. ([google.github.io](https://google.github.io/adk-docs/sessions/session/?utm_source=chatgpt.com))

---

## Roteiro minuto a minuto

### 0–10 min — Aquecimento: “por que RAG existe?”

**Analogia simples:**

- Imagine o LLM como um aluno inteligente **sem acesso ao caderno**. Ele sabe muita coisa, mas pode esquecer detalhes e inventar quando não lembra.
- **RAG é dar o caderno na hora da prova.**
    - Primeiro ele **procura** no caderno os trechos relevantes (Retrieval),
    - depois **responde usando aquilo** (Generation). ([Google Cloud](https://cloud.google.com/use-cases/retrieval-augmented-generation?utm_source=chatgpt.com))

**Quando usar (exemplos do dia a dia):**

- Chatbot que responde sobre regras da universidade.
- Assistente de suporte que consulta manuais internos.
- Agente que lê o TCC/relatórios e responde perguntas.

---

### 10–25 min — O que é ADK (sem complicar)

Explique **ADK como “framework de agentes com peças”**:

- **Agent**: o cérebro que fala com o modelo (Gemini etc.). ([GitHub](https://github.com/google/adk-python))
- **Tool**: uma habilidade extra (buscar na internet, rodar código, RAG…). ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
- **Runner**: o “maestro” que executa o agente, controla sessões e fluxo. ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
- **Session**: memória de conversa enquanto roda localmente (vamos usar in-memory). ([google.github.io](https://google.github.io/adk-docs/sessions/session/?utm_source=chatgpt.com))

**Mini analogia:**

ADK é tipo montar um robô:

- o Agent é o piloto,
- as Tools são ferramentas na mochila,
- o Runner é quem organiza a missão,
- e a Session é o diário do robô.

---

### 25–45 min — Como o RAG aparece dentro do ADK

Na documentação, o ADK tem uma ferramenta pronta:

- **`vertex_ai_rag_retrieval` / `VertexAiRagRetrieval`**
    
    Ela conecta o agente a um **corpus privado** do Vertex AI RAG Engine. ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
    

> O *corpus* é **a caixa onde você guarda todos os documentos** que o seu agente vai usar para responder perguntas.
> 
> 
> Imagine que você está montando um assistente que responde perguntas sobre **um livro**, **uma apostila**, **PDFs do cliente**, **regulamento da universidade**, etc.
> 
> O modelo (Gemini) sozinho não sabe o conteúdo exato desses documentos.
> 
> Então você cria **uma “biblioteca particular”**, que é o *corpus*.
> 
> Nessa biblioteca você coloca:
> 
> - PDFs
> - textos
> - FAQ
> - páginas da web
> - instruções técnicas
> - contratos
> - manuais
> - descrições de produtos
> - qualquer conteúdo **que você quer que o agente consulte antes de responder**
> 
> Essa biblioteca = **corpus**.
> 
> O RAG trabalha assim:
> 
> 1. Usuário pergunta →
> 2. O agente **procura trechos relevantes no corpus** →
> 3. O agente responde usando o que encontrou.

A doc oficial diz:

1. importar a tool,
2. configurar,
3. registrar no Agent. ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))

E ela já mostra um exemplo completo de uso com:

- `rag_resources` apontando pro corpus,
- `similarity_top_k`,
- `vector_distance_threshold`. ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))

---

### 45–70 min — Hands-on: criar o corpus (pré-feito ou guiado)

**Opção A (mais rápida em aula):** você já chega com um corpus criado e só passa o ID pro pessoal.

**Opção B (mostrar o passo a passo em 10–15 min):**

1. No GCP, habilitar Vertex AI.
    1. 
    
    [Configurando a Vertex](https://www.notion.so/Configurando-a-Vertex-2b1ff85eba7d808e963ff8f471191cf3?pvs=21)
    
2. Dar permissão `roles/aiplatform.user`.
3. Rodar o quickstart do RAG Engine pra criar um corpus e importar docs. ([Google Cloud Documentation](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/rag-engine/rag-quickstart?utm_source=chatgpt.com))

Saída disso: um ID parecido com:

```
projects/SEU_PROJETO/locations/us-central1/ragCorpora/123456

```

> Dica anti-perrengue: use from vertexai.preview import rag (é o import usado nos exemplos atuais; vertexai.rag costuma dar erro em versões recentes). (google.github.io)
> 

---

### 70–100 min — Hands-on: RAG Agent no ADK (código completo)

Crie um arquivo `rag_agent.py`:

```python
import os
import asyncio
from dotenv import load_dotenv

import vertexai
from vertexai.preview import rag  # importante: preview

from google.adk.agents import LlmAgent
from google.adk.runners import Runner
from google.adk.sessions import InMemorySessionService
from google.adk.tools.retrieval.vertex_ai_rag_retrieval import VertexAiRagRetrieval

load_dotenv()

PROJECT_ID = os.environ["PROJECT_ID"]
LOCATION = os.environ.get("LOCATION", "us-central1")
RAG_CORPUS = os.environ["RAG_CORPUS"]  # projects/.../ragCorpora/...

# Inicializa Vertex AI (necessário pro RAG Engine)
vertexai.init(project=PROJECT_ID, location=LOCATION)

# 1) Tool de Retrieval (RAG)
retrieval_tool = VertexAiRagRetrieval(
    name="kb_retriever",
    description="Busca trechos relevantes no corpus privado.",
    rag_resources=[rag.RagResource(rag_corpus=RAG_CORPUS)],
    similarity_top_k=5,
    vector_distance_threshold=0.6,
)

# 2) Agent com a tool registrada
agent = LlmAgent(
    name="rag_tutor",
    model="gemini-2.0-flash",
    instruction=(
        "Você é um tutor. Para responder perguntas sobre o material, "
        "use primeiro a ferramenta kb_retriever para buscar trechos relevantes. "
        "Depois responda de forma simples, citando o conteúdo encontrado."
    ),
    tools=[retrieval_tool],
)

# 3) Runner + Session local
runner = Runner(
    agent=agent,
    app_name="rag_aula",
    session_service=InMemorySessionService(),
)

async def chat():
    user_id = "aluno1"
    session_id = "sessao1"

    while True:
        q = input("Você: ")
        if q.lower() in ("sair", "exit", "quit"):
            break

        async for event in runner.run_async(
            user_id=user_id,
            session_id=session_id,
            new_message=q,
        ):
            if event.is_final_response():
                print("Agente:", event.content.parts[0].text)

if __name__ == "__main__":
    asyncio.run(chat())

```

Esse código segue a estrutura oficial:

- cria `VertexAiRagRetrieval` com corpus e parâmetros ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
- registra a tool no Agent ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
- roda tudo via Runner e sessão in-memory (padrão pra dev local). ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))

`.env` mínimo:

```
PROJECT_ID=seu-projeto
LOCATION=us-central1
RAG_CORPUS=projects/.../ragCorpora/123456

```

**Testes práticos pra turma:**

- “O que o documento diz sobre X?”
- “Resuma a parte Y em 3 tópicos.”
- “Onde no material aparece tal conceito?”

---

### 100–115 min — Exercícios rápidos (em duplas)

1. **Mudar o comportamento do agente**
    - Ajustar `similarity_top_k` pra 1, 3 e 10 e comparar respostas.
2. **Instrução melhor**
    - Mandar o agente responder **citando palavras do trecho recuperado**.
3. **Pergunta difícil**
    - Fazer o agente dizer “não achei isso no corpus” quando não recuperar nada.

---

### 115–125 min — Boas práticas (sem virar palestra)

- **Corpus bom > prompt longo**
    
    Uma base bem organizada vale mais que mil linhas de instrução.
    
- **Chunking importa** (se os docs forem grandes, dividir ajuda na busca).
- **top_k e threshold controlam ruído**
    - top_k alto traz mais coisa, mas pode misturar assuntos. ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
- Se quiser misturar RAG com outras tools, às vezes é melhor criar um sub-agente só de retrieval e chamá-lo do orquestrador (limitação conhecida). ([GitHub](https://github.com/google/adk-samples/issues/174?utm_source=chatgpt.com))

---

### 125–135 min — Fechamento

Peça pra cada dupla falar:

- uma pergunta que funcionou bem,
- uma que “alucinou” e como ajustariam corpus/tool/instruction.

Deixe claro o mapa mental:

> RAG no ADK = Tool de Retrieval + Agent bem instruído + Corpus bem feito.
> 

---

## Materiais recomendados pra você mandar depois

- Docs oficiais ADK (visão geral). ([google.github.io](https://google.github.io/adk-docs/?utm_source=chatgpt.com))
- Built-in tools e seção Vertex AI RAG Engine. ([google.github.io](https://google.github.io/adk-docs/tools/built-in-tools/))
- Quickstart do Vertex AI RAG Engine (criar corpus). ([Google Cloud Documentation](https://docs.cloud.google.com/vertex-ai/generative-ai/docs/rag-engine/rag-quickstart?utm_source=chatgpt.com))
- Repositório de samples do ADK (pra próximos exemplos). ([GitHub](https://github.com/google/adk-samples?utm_source=chatgpt.com))

---

Se quiser, eu adapto esse roteiro pra um **tema específico da sua turma** (ex.: RAG em documentos da EcompJr, uma disciplina da UEFS, ou material de um cliente) e já te deixo um corpus + exercícios alinhados.